<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-05-21">

<title>Simon</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="piactivity14_files/libs/clipboard/clipboard.min.js"></script>
<script src="piactivity14_files/libs/quarto-html/quarto.js"></script>
<script src="piactivity14_files/libs/quarto-html/popper.min.js"></script>
<script src="piactivity14_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="piactivity14_files/libs/quarto-html/anchor.min.js"></script>
<link href="piactivity14_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="piactivity14_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="piactivity14_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="piactivity14_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="piactivity14_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner {
        background: #002f8b;
      }
</style>


</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Simon</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 21, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#raspberry-pi-activity-simon" id="toc-raspberry-pi-activity-simon" class="nav-link active" data-scroll-target="#raspberry-pi-activity-simon"><span class="header-section-number">1</span> Raspberry Pi Activity: Simon</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">1.1</span> Introduction</a></li>
  <li><a href="#the-circuit" id="toc-the-circuit" class="nav-link" data-scroll-target="#the-circuit"><span class="header-section-number">1.2</span> The Circuit</a></li>
  <li><a href="#turning-the-leds-on-and-making-noise" id="toc-turning-the-leds-on-and-making-noise" class="nav-link" data-scroll-target="#turning-the-leds-on-and-making-noise"><span class="header-section-number">1.3</span> Turning the LEDs on and making noise!</a></li>
  <li><a href="#adding-switches" id="toc-adding-switches" class="nav-link" data-scroll-target="#adding-switches"><span class="header-section-number">1.4</span> Adding switches</a></li>
  <li><a href="#simon" id="toc-simon" class="nav-link" data-scroll-target="#simon"><span class="header-section-number">1.5</span> Simon</a></li>
  </ul></li>
  <li><a href="#homework-simon" id="toc-homework-simon" class="nav-link" data-scroll-target="#homework-simon"><span class="header-section-number">2</span> Homework: Simon</a></li>
  </ul>
</nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="raspberry-pi-activity-simon" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="raspberry-pi-activity-simon"><span class="header-section-number">1</span> Raspberry Pi Activity: Simon</h2>
<section id="introduction" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1.1</span> Introduction</h3>
<p>In this activity, you will implement a game that is similar to the popular (well, years ago anyways) game called Simon. Simon is an electronic memory skill game. Here’s an image of the game as manufactured by Milton Bradley:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/piactivity14-01.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>The game <em>board</em> is circular and has four large buttons that light up, each of a different color. Each color button has a musical note or tone associated with it. The game begins by randomly picking one (or sometimes two or even three) random colors. These randomly chosen colors are called a sequence. The game then plays the sequence by lighting up the appropriate colored buttons and playing the corresponding notes. The player then tries to replicate the sequence exactly. Any mistake, and the game ends. Each time the player successfully plays a sequence and matches the randomly selected colors, the sequence grows by an extra color.</p>
<p>For this activity, you will need the following items:</p>
<pre><code>• Raspberry Pi B v3 with power adapter;
• LCD touchscreen;
• Keyboard and mouse;
• USB-powered speakers;
• Breadboard;
• GPIO interface board with ribbon cable; and
• LEDs, resistors, switches, and jumper wires provided in your kit.</code></pre>
<p>Regarding the electronic components, you will need the following:</p>
<pre><code>• 1x red LED;
• 1x blue LED;
• 1x yellow LED;
• 1x green LED;
• 4x push-button switches;
• 4x 220Ω resistors; and
• 16x jumper wires.</code></pre>
</section>
<section id="the-circuit" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="the-circuit"><span class="header-section-number">1.2</span> The Circuit</h3>
<p>To begin, implement the following circuit:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/piactivity14-02.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Although you can wire the LEDs to different GPIO pins on the RPi, it will be easier if you follow the circuit diagram shown above because it will match the source code provided. Also, try to keep enough space for four push-button switches in between the GPIO-to-breadboard interface and the LEDs. This will make it easier to implement the other parts of this activity. Here’s one way to layout the circuit:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/piactivity14-03.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>If you have the black GPIO interface, layout the circuit as follows instead:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/piactivity14-04.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>For this part of the activity, you will simply turn the LEDs on, one at a time. As each LED is turned on, a corresponding note will play. You will use the Pygame library to play the notes. Pygame is a set of Python libraries that are useful for making games. For this activity, you will make use of its multimedia support (specifically, the ability to play sound files).</p>
<p>To play the notes, you will first need to obtain four sound files located on the class web site:</p>
<pre><code>• one.wav
• two.wav
• three.wav
• four.wav</code></pre>
<p>It is recommended that you create a folder for this activity and place the sound files there.</p>
<p>To hear the notes being played, you will need to use the USB-powered speakers. Connect the USB cable from the speakers to an open USB port on the RPi, and connect the audio cable from the speakers to the audio jack as shown below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/piactivity14-05.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</section>
<section id="turning-the-leds-on-and-making-noise" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="turning-the-leds-on-and-making-noise"><span class="header-section-number">1.3</span> Turning the LEDs on and making noise!</h3>
<p>Either using IDLE or a text editor, type the following Python code and save it to a file in the same folder as the sound files that you downloaded and saved earlier:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>   <span class="im">import</span> RPi.GPIO <span class="im">as</span> GPIO</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span>   <span class="im">from</span> time <span class="im">import</span> sleep</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span>   <span class="im">import</span> pygame</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span>   <span class="co"># initialize the pygame library</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span>   pygame.init()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span>   <span class="co"># set the GPIO pin numbers</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="dv">7</span>   <span class="co"># the LEDs (from L to R)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span>   leds <span class="op">=</span> [<span class="dv">6</span>, <span class="dv">13</span>, <span class="dv">19</span>, <span class="dv">21</span> ]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span>   <span class="co"># the sounds that map to each LED (from L to R)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span>  sounds <span class="op">=</span> [ pygame.mixer.Sound(<span class="st">"one.wav"</span>),</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"two.wav"</span>),</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"three.wav"</span>),</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"four.wav"</span>) ]</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span>  <span class="co"># use the Broadcom pin mode</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span>  GPIO.setmode(GPIO.BCM)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="dv">13</span>  <span class="co"># setup the output pins</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="dv">14</span>  GPIO.setup(leds, GPIO.OUT)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span>  <span class="bu">print</span>(<span class="st">"Watch the LEDs light with sound!"</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(leds)):</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="dv">17</span>      <span class="co"># light the current LED</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="dv">18</span>      GPIO.output(leds[i], <span class="va">True</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a><span class="dv">19</span>      <span class="co"># play its corresponding sound</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span>      sounds[i].play()</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span>      <span class="co"># wait a bit, then turn the LED off</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="dv">22</span>      sleep(<span class="dv">1</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="dv">23</span>      GPIO.output(leds[i], <span class="va">False</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span>      sleep(<span class="fl">0.5</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="dv">25</span>  <span class="bu">print</span>(<span class="st">"Sionara!"</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="dv">26</span>  GPIO.cleanup()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s explain the program. In lines 1 through 3, required libraries are imported. For this activity, we need GPIO functionality (since we’re turning on LEDs), the sleep function (to implement delays), and the Pygame library (to play the sound files).</p>
<p>In order to to use the modules in the Pygame library, it must first be initialized. This is done in line 5.</p>
<p>The next step is to setup the GPIO output pins that are wired to the LEDs in a list (in line 8). For this activity, the LEDs are wired to pins GP6= P22 (red), GP13= P23 (blue), GP19= P24 (yellow), and GP21= P29 (green). The sound files are also defined in a list and preloaded for later use (in line 10). In lines 11 through 14, the GPIO pin mode is specified, and the GPIO pins wired to the LEDs are setup as output pins.</p>
<p>The remainder of the source code (lines 15 through 25) turns each LED on, one at a time, plays each LED’s corresponding sound file, waits a few moments, and turns the LED off. If you need a refresher on GPIO in Python, it is suggested that you go back to Raspberry Pi Activity 2: My Binary Addiction…Reloaded. Line 26 cleans up the GPIO pins ands resets them to their defaults.</p>
<p>Get this part working before going on to the next part of the activity. Make sure that you see the LEDs turning on and off and hear the notes playing as each LED is briefly turned on. If the speakers aren’t working, you can try the following:</p>
<ol type="1">
<li>Make sure that both the speaker’s USB and audio cables are plugged in.</li>
<li>Make sure that the sound files are in the same folder as your .py source file.</li>
<li>Make sure that the sound files are spelled correctly (as they are named in the folder) in your source code. Remember that <strong>filenames are case sensitive!</strong></li>
<li>Make sure that the audio configuration on the RPi is set to output to the analog 3.5mm (headphone) jack. To do this, right-click on the speaker icon at the upper right of the desktop and select <strong>Analog.</strong></li>
<li>Make sure that the volume <em>wheel</em> on the back of one of the speakers is turned to the left (not quite all the way) and that the volume on the RPi is close (but not all the way) to its maximum (click on the speaker icon to set the volume on the RPi).</li>
<li>If you still have problems, open up a terminal (by clicking on the monitor icon at the upper left of the desktop) and type <code>amixer set PCM -- 100%</code>.</li>
<li>If you can hear the notes but they seem broken (e.g., with pops and clicks), you may need to turn the volume down on the speakers. Do this by sliding the volume <em>wheel</em> on the back of one of the speakers to the right a little until the notes are <em>clean</em>. Another option is to reduce the volume on the RPi by modifying the percentage value in the following terminal command: <code>amixer set PCM – 100%</code>. Try changing it to 85%, 75%, and so on, until the notes are clean.</li>
</ol>
</section>
<section id="adding-switches" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="adding-switches"><span class="header-section-number">1.4</span> Adding switches</h3>
<p>Extend your circuit to include four push-button switches. For this part of the activity, you will modify the previous circuit so that four push-button switches control the four LEDs. Pushing on the switches will turn on the appropriate LEDs and play the corresponding notes.</p>
<p>Add four switches to your circuit as show below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/piactivity14-06.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Here’s one way to layout this circuit:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/piactivity14-07.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>If you have the black GPIO interface, layout the circuit as follows instead:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/piactivity14-08.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Make sure that the switches are wired to +3.3V on one side and to an appropriate GPIO pin on the other side (GP26=P25, GP12=P26, GP16=P27, GP20= P28 in the figures above). The input pins will be pulled down (i.e., 0V) by default, and pushing on the switches will drive the input pins high. The goal will be to detect when this occurs so that the appropriate LED can be turned on.</p>
<p>You will now create a new Python program. Make sure that it is also saved in the same folder as the sound files that were downloaded earlier. In IDLE or a text editor, type in the following new program:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>   <span class="im">import</span> RPi.GPIO <span class="im">as</span> GPIO</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span>   <span class="im">from</span> time <span class="im">import</span> sleep</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span>   <span class="im">import</span> pygame</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span>   <span class="co"># initialize the pygame library</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span>   pygame.init()</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span>   <span class="co"># set the GPIO pin numbers</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="dv">7</span>   <span class="co"># the switches (from L to R)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span>   switches <span class="op">=</span> [ <span class="dv">20</span>, <span class="dv">16</span>, <span class="dv">12</span>, <span class="dv">26</span> ]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span>   <span class="co"># the LEDs (from L to R)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span>  leds <span class="op">=</span> [<span class="dv">6</span>, <span class="dv">13</span>, <span class="dv">19</span>, <span class="dv">21</span> ]</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span>  <span class="co"># the sounds that map to each LED (from L to R)</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span>  sounds <span class="op">=</span> [ pygame.mixer.Sound(<span class="st">"one.wav"</span>),</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"two.wav"</span>),</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"three.wav"</span>),</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"four.wav"</span>) ]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="dv">13</span>  <span class="co"># use the Broadcom pin mode</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="dv">14</span>  GPIO.setmode(GPIO.BCM)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span>  <span class="co"># setup the input and output pins</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span>  GPIO.setup(switches, GPIO.IN, pull_up_down<span class="op">=</span>GPIO.PUD_DOWN)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="dv">17</span>  GPIO.setup(leds, GPIO.OUT)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="dv">18</span>  <span class="bu">print</span>(<span class="st">"Press the switches or Ctrl+C to exit..."</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="dv">19</span>  <span class="co"># we'll discuss this later, but this allows us to detect</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span>  <span class="co"># when Ctrl+C is pressed so that we can reset the GPIO pins</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span>  <span class="cf">try</span>:</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="dv">22</span>      <span class="co"># keep going until the user presses Ctrl+C</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="dv">23</span>      <span class="cf">while</span> (<span class="va">True</span>):</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span>          <span class="co"># initially note that no switch is pressed</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a><span class="dv">25</span>          <span class="co"># this will help with switch debouncing</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="dv">26</span>          pressed <span class="op">=</span> <span class="va">False</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="dv">27</span>          <span class="co"># so long as no switch is currently pressed...</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a><span class="dv">28</span>          <span class="cf">while</span> (<span class="kw">not</span> pressed):</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="dv">29</span>              <span class="co"># ...we can check the status of each switch</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="dv">30</span>              <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(switches)):</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a><span class="dv">31</span>                  <span class="co"># if one switch is pressed</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a><span class="dv">32</span>                  <span class="cf">while</span> (GPIO.<span class="bu">input</span>(switches[i]) <span class="op">==</span> <span class="va">True</span>):</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="dv">33</span>                      <span class="co"># note its index</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a><span class="dv">34</span>                      val <span class="op">=</span> i</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a><span class="dv">35</span>                      <span class="co"># note that a switch has now been pressed</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a><span class="dv">36</span>                      pressed <span class="op">=</span> <span class="va">True</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a><span class="dv">37</span>          <span class="co"># light the matching LED</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a><span class="dv">38</span>          GPIO.output(leds[val], <span class="va">True</span>)</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a><span class="dv">39</span>          <span class="co"># play its corresponding sound</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a><span class="dv">40</span>          sounds[val].play()</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a><span class="dv">41</span>          <span class="co"># wait and turn the LED off again</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span>          sleep(<span class="dv">1</span>)</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a><span class="dv">43</span>          GPIO.output(leds[val], <span class="va">False</span>)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a><span class="dv">44</span>          sleep(<span class="fl">0.25</span>)</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a><span class="dv">45</span>  <span class="co"># detect Ctrl+C</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a><span class="dv">46</span>  <span class="cf">except</span> <span class="pp">KeyboardInterrupt</span>:</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a><span class="dv">47</span>  <span class="co"># reset the GPIO pins</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a><span class="dv">48</span>  GPIO.cleanup()</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a><span class="dv">49</span>  <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Sionara!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should notice that some of this new program is similar to the previous one. The first difference is that a new list is defined that stores the GPIO pins that are wired to the push-button switches (in line 8). Make sure that the specified GPIO pins match the connections on your breadboard.</p>
<p>Since we now have input pins, they need to be defined as such. This is done in line 16. Note that the input pins are pulled down by default.</p>
<p>Note the try-except construct (lines 21 and 46). Although you should have seen this before, it hasn’t yet been thoroughly explained. Essentially, a try-except construct encapsulates any part of a Python program that could potentially experience abnormal program behavior. In this case, the goal is to detect when a user presses Ctrl+C. If this key combination is detected, we wish to reset the GPIO pins (thereby resetting them to their defaults), and exit the program (lines 48 through 49).</p>
<p>The goal of the program is to continually wait for a switch to be pressed. When one is pressed, the program tries to detect which one it is, and light the appropriate LED. After a brief moment, the program should wait for another switch to be pressed. The only way to end the program is to press Ctrl+C. To check for switch presses indefinitely, the program uses a while loop. Note the condition of this while loop in line 23. Since the condition is always true, the while loop executes forever! But this is OK, since we are allowing Ctrl+C to abort and exit the program.</p>
<p>When reading switch presses, we must worry about an issue called debouncing. Switch debouncing prevents a single press of a push-button switch from appearing like multiple presses. This is something that we generally have to live with when using switches in digital circuits. The tactic in this program is to utilize a Boolean variable called pressed that detects when any one of the switches is pressed. Initially, it is set to false (i.e., no switch is pressed) in line 26. The while loop beginning at line 28 is then entered. When any one of the switches is pressed, the variable is toggled to true (line 36). This breaks control out of the while loop, allowing the appropriate LED to be turned on and the corresponding note to be played (lines 37 through 44). Since the variable is toggled to true, then no other switch press can be detected until it is reset to false.</p>
<p>Detecting which switch is pressed (if any), is done in the for loop beginning at line 30. The program checks the state of each switch, one by one (line 32). While any switch is pressed (i.e., its wired input pin is high), its index is noted (line 34). A switch’s index corresponds to the index of the LED in the list of LEDs that it controls (and the sound file that should be played). Once a switch press has been detected, the variable pressed is set to true in line 36 (which breaks out of the while loop beginning at line 28).</p>
<p>Again, once a switch has been pressed, the appropriate LED is turned on, and the corresponding sound file is played (lines 37 through 40). After a brief moment, the LED is turned back off (lines 41 through 44), and the outer while loop beginning at line 23 begins again.</p>
<p>Get this part working before going on to the next part of the activity. Make sure that you see the LEDs turning on and off as you press the switches. Make sure that you hear the notes playing as each LED is briefly turned on.</p>
</section>
<section id="simon" class="level3" data-number="1.5">
<h3 data-number="1.5" class="anchored" data-anchor-id="simon"><span class="header-section-number">1.5</span> Simon</h3>
<p>The parts of the activity that you have already implemented provide almost all that is needed to lay the base for the game. The only thing left to add is a way to generate a random sequence of colors, allow the player to push buttons that correspond the to sequence, check if the player’s sequence matches the one in the game, and either grow the sequence or end the game!</p>
<p>First, here’s the code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>   <span class="im">import</span> RPi.GPIO <span class="im">as</span> GPIO</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span>   <span class="im">from</span> time <span class="im">import</span> sleep</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span>   <span class="im">from</span> random <span class="im">import</span> randint</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span>   <span class="im">import</span> pygame</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span>   <span class="co"># set to True to enable debugging output</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span>   DEBUG <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="dv">7</span>   <span class="co"># initialize the pygame library</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span>   pygame.init()</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span>   <span class="co"># set the GPIO pin numbers</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span>  <span class="co"># the switches (from L to R)</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span>  switches <span class="op">=</span> [ <span class="dv">20</span>, <span class="dv">16</span>, <span class="dv">12</span>, <span class="dv">26</span> ]</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span>  <span class="co"># the LEDs (from L to R)</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="dv">13</span>  leds <span class="op">=</span> [<span class="dv">6</span>, <span class="dv">13</span>, <span class="dv">19</span>, <span class="dv">21</span> ]</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="dv">14</span>  <span class="co"># the sounds that map to each LED (from L to R)</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span>  sounds <span class="op">=</span> [ pygame.mixer.Sound(<span class="st">"one.wav"</span>),</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"two.wav"</span>),</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"three.wav"</span>),</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    pygame.mixer.Sound(<span class="st">"four.wav"</span>) ]</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span>  <span class="co"># use the Broadcom pin mode</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="dv">17</span>  GPIO.setmode(GPIO.BCM)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="dv">18</span>  <span class="co"># setup the input and output pins</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="dv">19</span>  GPIO.setup(switches, GPIO.IN, pull_up_down<span class="op">=</span>GPIO.PUD_DOWN)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span>  GPIO.setup(leds, GPIO.OUT)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span>  <span class="co"># this function turns the LEDs on</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="dv">22</span>  <span class="kw">def</span> all_on():</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="dv">23</span>      <span class="cf">for</span> i <span class="kw">in</span> leds:</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span>          GPIO.output(leds, <span class="va">True</span>)</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="dv">25</span>  <span class="co"># this function turns the LEDs off</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="dv">26</span>  <span class="kw">def</span> all_off():</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="dv">27</span>      <span class="cf">for</span> i <span class="kw">in</span> leds:</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="dv">28</span>          GPIO.output(leds, <span class="va">False</span>)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="dv">29</span>  <span class="co"># this functions flashes the LEDs a few times when the player loses the game</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="dv">30</span>  <span class="kw">def</span> lose():</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="dv">31</span>      <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">4</span>):</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="dv">32</span>          all_on()</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a><span class="dv">33</span>          sleep(<span class="fl">0.5</span>)</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a><span class="dv">34</span>          all_off()</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a><span class="dv">35</span>          sleep(<span class="fl">0.5</span>)</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a><span class="dv">36</span>  <span class="co"># the main part of the program</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="dv">37</span>  <span class="co"># initialize the Simon sequence</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a><span class="dv">38</span>  <span class="co"># each item in the sequence represents an LED (or switch), indexed at 0 through 3</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a><span class="dv">39</span>  seq <span class="op">=</span> []</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a><span class="dv">40</span>  <span class="co"># randomly add the first two items to the sequence</span></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a><span class="dv">41</span>  seq.append(randint(<span class="dv">0</span>, <span class="dv">3</span>))</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span>  seq.append(randint(<span class="dv">0</span>, <span class="dv">3</span>))</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a><span class="dv">43</span>  <span class="bu">print</span>(<span class="st">"Welcome to Simon!"</span>)</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a><span class="dv">44</span>  <span class="bu">print</span>(<span class="st">"Try to play the sequence back by pressing the switches."</span>)</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a><span class="dv">45</span>  <span class="bu">print</span>(<span class="st">"Press Ctrl+C to exit..."</span>)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a><span class="dv">46</span>  <span class="co"># we'll discuss this later, but this allows us to detect</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a><span class="dv">47</span>  <span class="co"># when Ctrl+C is pressed so that we can reset the GPIO pins</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a><span class="dv">48</span>  <span class="cf">try</span>:</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a><span class="dv">49</span>      <span class="co"># keep going until the user presses Ctrl+C</span></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a><span class="dv">50</span>      <span class="cf">while</span> (<span class="va">True</span>):</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a><span class="dv">51</span>          <span class="co"># randomly add one more item to the sequence</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a><span class="dv">52</span>          seq.append(randint(<span class="dv">0</span>, <span class="dv">3</span>))</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a><span class="dv">53</span>          <span class="cf">if</span> (DEBUG):</span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a><span class="dv">54</span>              <span class="co"># display the sequence to the console</span></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span>              <span class="cf">if</span> (<span class="bu">len</span>(seq) <span class="op">&gt;</span> <span class="dv">3</span>):</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a><span class="dv">56</span>                  <span class="bu">print</span>()</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a><span class="dv">57</span>                  <span class="bu">print</span>(<span class="st">"seq=</span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(seq))</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a><span class="dv">58</span>          <span class="co"># display the sequence using the LEDs</span></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a><span class="dv">59</span>          <span class="cf">for</span> s <span class="kw">in</span> seq:</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a><span class="dv">60</span>              <span class="co"># turn the appropriate LED on</span></span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a><span class="dv">61</span>              GPIO.output(leds[s], <span class="va">True</span>)</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a><span class="dv">62</span>              <span class="co"># play its corresponding sound</span></span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a><span class="dv">63</span>              sounds[s].play()</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a><span class="dv">64</span>              <span class="co"># wait and turn the LED off again</span></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a><span class="dv">65</span>              sleep(<span class="dv">1</span>)</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a><span class="dv">66</span>              GPIO.output(leds[s], <span class="va">False</span>)</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a><span class="dv">67</span>              sleep(<span class="fl">0.5</span>)</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a><span class="dv">68</span>          <span class="co"># wait for player input (via the switches)</span></span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a><span class="dv">69</span>          <span class="co"># initialize the count of switches pressed to 0</span></span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a><span class="dv">70</span>          switch_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a><span class="dv">71</span>          <span class="co"># keep accepting player input until the number of items in the sequence is reached</span></span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a><span class="dv">72</span>          <span class="cf">while</span> (switch_count <span class="op">&lt;</span> <span class="bu">len</span>(seq)):</span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a><span class="dv">73</span>              <span class="co"># initially note that no switch is pressed</span></span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a><span class="dv">74</span>              <span class="co"># this will help with switch debouncing</span></span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a><span class="dv">75</span>              pressed <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a><span class="dv">76</span>              <span class="co"># so long as no switch is currently pressed...</span></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a><span class="dv">77</span>              <span class="cf">while</span> (<span class="kw">not</span> pressed):</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a><span class="dv">78</span>              <span class="co"># ...we can check the status of each switch</span></span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a><span class="dv">79</span>                  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(switches)):</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a><span class="dv">80</span>                      <span class="co"># if one switch is pressed</span></span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a><span class="dv">81</span>                      <span class="cf">while</span> (GPIO.<span class="bu">input</span>(switches[i]) <span class="op">==</span> <span class="va">True</span>):</span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a><span class="dv">82</span>                          <span class="co"># note its index</span></span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a><span class="dv">83</span>                          val <span class="op">=</span> i</span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a><span class="dv">84</span>                          <span class="co"># note that a switch has now been pressed</span></span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a><span class="dv">85</span>                          <span class="co"># so that we don't detect any more switch presses</span></span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a><span class="dv">86</span>                          pressed <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a><span class="dv">87</span>              <span class="cf">if</span> (DEBUG):</span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a><span class="dv">88</span>                  <span class="co"># display the index of the switch pressed</span></span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a><span class="dv">89</span>                      <span class="bu">print</span>(val)</span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a><span class="dv">90</span>              <span class="co"># light the matching LED</span></span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a><span class="dv">91</span>              GPIO.output(leds[val], <span class="va">True</span>)</span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a><span class="dv">92</span>              <span class="co"># play its corresponding sound</span></span>
<span id="cb6-111"><a href="#cb6-111" aria-hidden="true" tabindex="-1"></a><span class="dv">93</span>              sounds[val].play()</span>
<span id="cb6-112"><a href="#cb6-112" aria-hidden="true" tabindex="-1"></a><span class="dv">94</span>              <span class="co"># wait and turn the LED off again</span></span>
<span id="cb6-113"><a href="#cb6-113" aria-hidden="true" tabindex="-1"></a><span class="dv">95</span>              sleep(<span class="dv">1</span>)</span>
<span id="cb6-114"><a href="#cb6-114" aria-hidden="true" tabindex="-1"></a><span class="dv">96</span>              GPIO.output(leds[val], <span class="va">False</span>)</span>
<span id="cb6-115"><a href="#cb6-115" aria-hidden="true" tabindex="-1"></a><span class="dv">97</span>              sleep(<span class="fl">0.25</span>)</span>
<span id="cb6-116"><a href="#cb6-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-117"><a href="#cb6-117" aria-hidden="true" tabindex="-1"></a><span class="dv">98</span>              <span class="co"># check to see if this LED is correct in the sequence</span></span>
<span id="cb6-118"><a href="#cb6-118" aria-hidden="true" tabindex="-1"></a><span class="dv">99</span>              <span class="cf">if</span> (val <span class="op">!=</span> seq[switch_count]):</span>
<span id="cb6-119"><a href="#cb6-119" aria-hidden="true" tabindex="-1"></a><span class="dv">100</span>                 <span class="co"># player is incorrect; invoke the lose function</span></span>
<span id="cb6-120"><a href="#cb6-120" aria-hidden="true" tabindex="-1"></a><span class="dv">101</span>                 lose()</span>
<span id="cb6-121"><a href="#cb6-121" aria-hidden="true" tabindex="-1"></a><span class="dv">102</span>                 <span class="co"># reset the GPIO pins</span></span>
<span id="cb6-122"><a href="#cb6-122" aria-hidden="true" tabindex="-1"></a><span class="dv">103</span>                 GPIO.cleanup()</span>
<span id="cb6-123"><a href="#cb6-123" aria-hidden="true" tabindex="-1"></a><span class="dv">104</span>                 <span class="co"># exit the game</span></span>
<span id="cb6-124"><a href="#cb6-124" aria-hidden="true" tabindex="-1"></a><span class="dv">105</span>                 exit(<span class="dv">0</span>)</span>
<span id="cb6-125"><a href="#cb6-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-126"><a href="#cb6-126" aria-hidden="true" tabindex="-1"></a><span class="dv">106</span>             <span class="co"># if the player has this item in the sequence correct, increment the count</span></span>
<span id="cb6-127"><a href="#cb6-127" aria-hidden="true" tabindex="-1"></a><span class="dv">107</span>             switch_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-128"><a href="#cb6-128" aria-hidden="true" tabindex="-1"></a><span class="dv">108</span> <span class="co"># detect Ctrl+C</span></span>
<span id="cb6-129"><a href="#cb6-129" aria-hidden="true" tabindex="-1"></a><span class="dv">109</span> <span class="cf">except</span> <span class="pp">KeyboardInterrupt</span>:</span>
<span id="cb6-130"><a href="#cb6-130" aria-hidden="true" tabindex="-1"></a><span class="dv">110</span> <span class="co"># reset the GPIO pins</span></span>
<span id="cb6-131"><a href="#cb6-131" aria-hidden="true" tabindex="-1"></a><span class="dv">111</span> GPIO.cleanup()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To support randomly generating the sequence, the random library is imported in line 3. Also, it is often useful to display debugging information while developing applications. In the case of Simon, it is useful to show the randomly generated sequence, and the player’s submitted sequence. This can help during testing. The debug variable is set in line 6. When it is set to false, no debugging information is shown.</p>
<p>Lines 7 through 20 are the same as the last part of this activity. Lines 21 through 35 define three new functions. The first simply turns all of the LEDs on. The second turns all of the LEDs off. The third is invoked when the player loses the game. This function blinks all of the LEDs a few times before the game ends.</p>
<p>Lines 39 through 42 setup the empty sequence and add two random colors to the sequence. After some short introduction text, the game officially begins with the while loop beginning at line 50.</p>
<p>Each time the while loop iterates, a new random color is added to the sequence (line 52). If debugging is enabled, the sequence is then displayed to the console (lines 55 through 57). The game then displays the sequence, turning on the appropriate LEDs and playing the corresponding notes, one by one (lines 59 through 67).</p>
<p>Since we now want to detect the pressing of multiple switches sequentially (i.e., we need to detect the player’s submission for the entire sequence), a counter is initialized (line 70) and is increased each time the player presses a switch (later in line 107). The program accepts as many switch presses as there are colors in the sequence (line 72). The detection of which switch is pressed is the same as in the previous part of the activity (lines 75 through 86). If debugging is enabled, the index of the pressed switch is displayed to the console (line 89).</p>
<p>Lines 90 through 97 turn the LED on that corresponds to the player’s switch press, plays the corresponding note, waits a brief moment, then turns the LED off. Line 99 then checks to make sure that the player’s switch press is indeed the right one in the sequence. If not, the player loses and the game ends (lines 101 through 105).</p>
</section>
</section>
<section id="homework-simon" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="homework-simon"><span class="header-section-number">2</span> Homework: Simon</h2>
<p>For the homework portion of this activity, you may have the option to work in <strong>groups</strong> (pending prof approval). It is suggested that groups contain at least one confident Python coder.</p>
<p>The <strong>first part</strong> of this activity is to implement the Simon program in this activity. Please work to understand the algorithm and source code instead of merely typing it in (or, worse, using a copy/paste process). Once your Simon game is working properly, you can move on the the second part of this activity.</p>
<p>For the <strong>second part</strong> of this activity, you must implement several improvements:</p>
<ol type="1">
<li><p><strong>A scoring mechanism</strong>. When the player makes a mistake and the game ends, output a message similar to, “You made it to a sequence of 9!” Remember that failing at the start should output something like, “You made it to a sequence of 0!” or, “You didn’t even make it to a sequence!”</p></li>
<li><p><strong>Over time, increase the speed of the playing sequence</strong>. As the player is more and more successful, increase the speed of the sequence as it is played back to the player. The time spent playing each note in a sequence is currently 1s. Furthermore, the delay in between playing the notes is currently 0.5s. Modify this as follows:</p>
<ol type="1">
<li>Once the sequence gets to <strong>five notes</strong>, the time spent playing each each note should be decreased to <strong>0.9s</strong>; the delay in between playing the notes should be decreased to <strong>0.4s</strong>.</li>
<li>Once the sequence gets to <strong>seven notes</strong>, the time spent playing each each note should be decreased to <strong>0.8s</strong>; the delay in between playing the notes should be decreased to <strong>0.3s</strong>.</li>
<li>Once the sequence gets to <strong>ten notes</strong>, the time spent playing each each note should be decreased to <strong>0.7s</strong>; the delay in between playing the notes should be decreased to <strong>0.25s</strong>.</li>
<li>Once the sequence gets to <strong>thirteen notes</strong>, the time spent playing each each note should be decreased to <strong>0.6s</strong>; the delay in between playing the notes should be decreased to <strong>0.15s</strong>.</li>
</ol>
<p><strong>Note that this should not affect the normal play and delay times when the player presses the switches!</strong></p></li>
<li><p><strong>Over time, no longer use the LEDs when playing the sequence</strong>. Once the sequence gets to fifteen notes, stop turning LEDs on/off. That is, the player is evidently so good at this point that the sequence should only be played audibly. The play and delay times should be as described in (2) above (i.e., the same times as a sequence of thirteen notes).</p>
<p><strong>Note that this should not affect the normal behavior of the LEDs when the player presses the switches!</strong></p></li>
</ol>
<p><strong>You are to submit your Python source code only (as a .py file) through the upload facility on the web site.</strong></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>