<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-08-28">

<title>Introduction to Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="lesson03_files/libs/clipboard/clipboard.min.js"></script>
<script src="lesson03_files/libs/quarto-html/quarto.js"></script>
<script src="lesson03_files/libs/quarto-html/popper.min.js"></script>
<script src="lesson03_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="lesson03_files/libs/quarto-html/anchor.min.js"></script>
<link href="lesson03_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="lesson03_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="lesson03_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="lesson03_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="lesson03_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#problem-statements-wrong-vs.-right-algorithms" id="toc-problem-statements-wrong-vs.-right-algorithms" class="nav-link" data-scroll-target="#problem-statements-wrong-vs.-right-algorithms"><span class="header-section-number">2</span> Problem statements: wrong vs.&nbsp;right algorithms</a></li>
  <li><a href="#step-breakdown-and-control-flow" id="toc-step-breakdown-and-control-flow" class="nav-link" data-scroll-target="#step-breakdown-and-control-flow"><span class="header-section-number">3</span> Step breakdown and control flow</a></li>
  <li><a href="#flowcharts" id="toc-flowcharts" class="nav-link" data-scroll-target="#flowcharts"><span class="header-section-number">4</span> Flowcharts</a></li>
  <li><a href="#repetition" id="toc-repetition" class="nav-link" data-scroll-target="#repetition"><span class="header-section-number">5</span> Repetition</a></li>
  <li><a href="#efficiency-and-runtime" id="toc-efficiency-and-runtime" class="nav-link" data-scroll-target="#efficiency-and-runtime"><span class="header-section-number">6</span> Efficiency and runtime</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Introduction to Algorithms</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 28, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>In this lesson, you will learn about one of the most fundamental concepts in computer science: algorithms.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Definition">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition
</div>
</div>
<div class="callout-body-container callout-body">
<p>An <strong>algorithm</strong> is a detailed sequence of steps that describes how to solve a problem or accomplish some task.</p>
</div>
</div>
<p>First, consider the process of identifying problems and their possible solutions, and breaking those solutions down into a sequence of steps. One way to do this is via simple to-do lists. Consider the problem of getting to class in the morning. Assume that you have just woken up (that is, after you hit the snooze button a good dozen or so times). What steps did you take to prepare and get to class? A possible list of steps is:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>get out of bed</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>brush teeth</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>take shower</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>get dressed</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>eat breakfast</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>grab book-bag</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>walk/bike/drive to class</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This to-do list is actually a useful way to tell someone who didn’t know what to do in the morning to prepare to get to class, what to do.</p>
<p>Another example of a problem is that of baking an apple pie. What would a to-do list that would show someone who didn’t know how to bake an apple pie look like? Could there be multiple ways of baking apple pie? If so, how can we determine which one is the <em>best</em>? Truly, this is subjective; however, the idea of picking a best solution is one that is required in computer science.</p>
<p>A possible solution to baking an apple pie as a to-do list may look like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>make the dough</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>make the apple goop</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>combine the two</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>bake the dough with the goop</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>eat hot apple pie (with vanilla ice cream, of course)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>What does an algorithm that describes how to bake apple pie in the <em>best</em> manner mean? Is it the algorithm that takes the shortest time to produce hot apple pie? Is it the algorithm that uses the fewest ingredients? Is it the algorithm that makes less of a mess in the kitchen and therefore requires less cleanup? These questions are designed to illustrate that the notion of best algorithm is many times quite subjective and does not always have a definite (or even a single) answer. However, the comparison of algorithms numerically to show the performance of one against another is quite important in computer science. This will help in determining if one is better than another, with the end goal being to identify a best algorithm.</p>
<p>Does a wrong algorithm for producing apple pie exist? What solutions or algorithms will not work? What happens if a person uses blueberries instead of apples? Is the original problem of baking an apple pie solved then?</p>
</section>
<section id="problem-statements-wrong-vs.-right-algorithms" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="problem-statements-wrong-vs.-right-algorithms"><span class="header-section-number">2</span> Problem statements: wrong vs.&nbsp;right algorithms</h2>
<p>It is important to define standard ways of representing problems so that anyone who reads about a problem can understand what it actually is.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Definition">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition
</div>
</div>
<div class="callout-body-container callout-body">
<p>A <strong>problem statement</strong> is a formal way of defining a problem that contains a description of the conditions at the start of the problem solving process (also known as inputs), and a description of the valid solutions (also referred to as outputs).</p>
</div>
</div>
<p>For example, if a problem was to add three numbers and produce the sum, what would the inputs be? The answer, of course, is the three numbers! What would the output be? Clearly, the sum of those three numbers. If a problem was to determine the amount of income tax owed this year, what would the inputs be? Your income. And the output? The amount of tax owed this year. The following figure illustrates the sum example (generally on the left, and specific to the sum of three numbers on the right):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-01.png" class="img-fluid figure-img"></p>
</figure>
</div>
<p>Consider the <em>producing apple pie</em> problem. What would the possible inputs for the algorithm be? What would its valid (or correct) output(s) be? One way of telling if an algorithm is correct is whether or not it produces the valid output defined in the problem statement. If an algorithm produces blueberry pie when the output statement stated that it was required to produce apple pie, then that algorithm is a wrong solution. On the other hand, if the output is an apple pie (even if the algorithm instructs you to throw away your ingredients and then buy an apple pie from the grocery store), then that algorithm is technically correct (even though it may not be very <em>efficient</em>).</p>
</section>
<section id="step-breakdown-and-control-flow" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="step-breakdown-and-control-flow"><span class="header-section-number">3</span> Step breakdown and control flow</h2>
<p>Consider the get to class algorithm. It consisted of steps such as brush teeth, get dressed, and eat breakfast. Some of these steps can actually be defined as problems of their own, which themselves require different algorithms in order to be successfully completed. What this means is that some of these steps can be broken down into their own algorithms with a separate to-do list. We call these sub-steps. A possible algorithm for the problem of getting dressed is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>put on underwear</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>put on shorts</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>put on shirt</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>put on socks</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>put on shoes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This illustrates that we can zoom in to any step in an algorithm and break it down into a series of smaller steps. Note that it is possible to arrive at a trivial step that does not require any smaller steps or that does not have a simpler way to describe it.</p>
<p>So what should be done to our original get to class algorithm? Should getting dressed be replaced with the five new sub-steps identified above? Is the overall solution more correct or less correct if we do that? In the end, both solutions work and neither is specifically better than the other. It all depends on the desired level of detail. If the person for whom the algorithm was intended for knew how to get dressed, then a separate algorithm to explain that would not be needed. However, if the person didn’t know how to get dressed, then these sub-steps would be very important.</p>
<p>Let’s go back to the <em>producing apple pie</em> problem. What do you think would happen if the order of the steps was changed in the proposed solution? What if the raw ingredients used to make the dough and goop were baked <em>before</em> putting them together? In this case, there would be a very messy oven instead of an apple pie. What if the apple goop was made before making the dough? In this case, apple pie would still be the delicious result. There are times when the order in which the steps of an algorithm are carried out matters a lot and other cases when it doesn’t matter as much.</p>
<p>Consider the <em>get to class</em> algorithm again. What would happen if the order of the steps was changed? Imagine getting dressed before taking a shower. Imagine walking/biking/driving to class before getting dressed. Let’s not. Could a shower be taken before brushing teeth? Could breakfast be eaten before brushing teeth?</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Definition">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Control flow</strong> is the order in which the instructions in an algorithm are evaluated or executed.</p>
</div>
</div>
<p>In the examples considered so far, the control flow of algorithms has been the order in which the steps were listed. Each step is evaluated or performed until it is complete, and then we move on to the next step. Completing all the steps completes the to-do list, thereby completing the algorithm. Numbering the items listed in a to-do lists is an easy way of detailing the order in which the steps should be completed. A possible numbered solution to the <em>get to class</em> algorithm is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>1. get out of bed</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>2. brush teeth</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>3. take shower</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>4. get dressed</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>5. eat breakfast</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>6. grab backpack</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>7. walk/bike/drive to class</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We say that <em>flow of control</em> begins at step 1, flows to step 2, then to step 3, and so on. This means that step 1 is completed first before attempting step 2. Step 5 should not be done before step 4 is completed.</p>
<p>What about the <em>get to class</em> algorithm in which separate sub-steps for <em>get dressed</em> were specified (step 4 in the algorithm above)? To combine the two algorithms, numbers can be assigned to the steps in the <em>get dressed</em> algorithm to show the order in which they will be executed in <em>relation</em> to the <em>get to class</em> algorithm – which will now look like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>1. get out of bed</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>2. brush teeth</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>3. take shower</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>4. get dressed</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>10. eat breakfast</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>11. grab backpack</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>12. walk/bike/drive to class</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The get dressed algorithm will now look like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>5. put on underwear</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>6. put on shorts</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>7. put on shirt</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>8. put on socks</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>9. put on shoes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice how steps 1 through 4 of the go to class algorithm are the same and done in the same order. However, we shift the flow of control to the get dressed algorithm which used to be step 5 in the original. We have to execute the get dressed step (meaning its sub-steps) completely before proceeding to the eat breakfast step. However, the get dressed step consists of five sub-steps, and so we number those steps before continuing to the eat breakfast step. This means that the first sub-step in the get dressed algorithm is step 5. We have to complete the get dressed algorithm before returning to the get to class algorithm. Thus, the eat breakfast step becomes step 10 since the last step of the get dressed algorithm is step 9. The entire algorithm ends when we execute the last step of the get to class algorithm, which is step 12.</p>
</section>
<section id="flowcharts" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="flowcharts"><span class="header-section-number">4</span> Flowcharts</h2>
<p>Up to this point, to-do lists have been used to represent algorithms. There are other ways of representing algorithms, however, and one of them is by using flowcharts.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Definition">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition
</div>
</div>
<div class="callout-body-container callout-body">
<p>A <strong>flowchart</strong> is a type of diagram that represents an algorithm, listing steps with various blocks and flow with arrows.</p>
</div>
</div>
<p>Flowcharts are made up of different types of blocks, each of a different shape. The shapes correspond to different kinds of statements or types of item. Flowcharts use arrows to show the direction of execution of a given algorithm. An arrow leading from a block A to a block B means that A is executed before B.</p>
<p>To symbolize where the algorithm starts and ends, we have a special kind of block called the <strong>terminal block</strong>. Terminal blocks are oval in shape and identify where an algorithm starts and where it ends. The start block will always have one arrow leading out of it to the next block to be executed, and the stop block will always have at least one arrow leading into it from some previous block. Here is what a terminal block looks like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-02.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Terminal block</figcaption>
</figure>
</div>
<p>A <strong>process block</strong> represents statements in which some action is performed. It is shaped like a rectangle. Typically, this block will have one arrow leading into it from a block that was executed before. It will also have an arrow leading out of it to the block that should be executed next. Here is what a process block looks like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-03.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Process block</figcaption>
</figure>
</div>
<p>An input/output block is shaped like a parallelogram. These blocks are used whenever an algorithm requires an input or produces an output. Similar to the process block, this block will have an arrow leading to it from a previous block, and an arrow leading out of it to the next block. Here is what an input/output block looks like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-04.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Input/Output block</figcaption>
</figure>
</div>
<p>Here is a possible flowchart that represents the solution to the get dressed algorithm:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-05.png" class="img-fluid figure-img"></p>
</figure>
</div>
<p>Are there any weaknesses with this algorithm? Will it always work and produce the desired output? For example, will it work if someone already has underwear on? The current algorithm would force the person already wearing underwear to put on a second one. What would happen if the shirt they found was dirty, but they wanted to wear clean clothes instead? This algorithm would force the person to wear the dirty clothes.</p>
<p>These are examples of scenarios that call for <em>decisions</em> to be made and instructions to be decided on that are executed based on answers to simple questions. For example, skipping the <em>put on underwear</em> step would be useful if the person already had underwear on. Perhaps adding a step <em>find clean shirt</em> to the algorithm would handle the case that an original shirt is dirty.</p>
<p>It is difficult to handle these decisions in a traditional to-do list, but flowcharts deal with them in a pretty neat way by using <strong>decision blocks</strong>. Decision blocks are diamond-shaped and typically contain a question with a yes or no answer. Similar to the previous blocks, the decision block will have one arrow leading into it from the preceding block. However, decision blocks can have two arrows leading out that go to two different blocks. One of those blocks is executed if the answer to the question posed in the decision block is <em>yes</em>, and the other block is executed if the answer is <em>no</em>. Here is what a decision block looks like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-06.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Decision block</figcaption>
</figure>
</div>
<p>Let’s look at an improved flowchart for the get dressed algorithm that has a decision block. A possible solution is:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-07.png" class="img-fluid figure-img"></p>
</figure>
</div>
<p>One of the great things about decision blocks (and flowcharts in general) is that you can have different control flows based on decisions made by the algorithm. The algorithm doesn’t always have to behave the same way and can actually change its behavior based on what is happening during its execution. The algorithm designer, however, has to think up all possible scenarios and cater for them when designing an algorithm.</p>
<div class="callout callout-style-default callout-important callout-titled" title="Activity">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Activity
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Design a flowchart for the <em>eat breakfast</em> algorithm. This time, add a decision block with the question <em>am I satisfied?</em> in an appropriate position, such that the algorithm will always ensure that the person eating breakfast only stops eating once satisfied.</p>
</div>
</div>
</div>
</section>
<section id="repetition" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="repetition"><span class="header-section-number">5</span> Repetition</h2>
<p>You may have observed from the eat breakfast flowchart that it is possible to use decision blocks to repeat a task an indefinite number of times. Repetition is a feature of many algorithms.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Definition">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Repetition</strong> is the repeating of a task (or tasks) over and over again. It is accompanied by a decision/condition that controls when the repetition ends. This is sometimes referred to as <strong>iterating</strong>, and each loop that is repeated is referred to as an <strong>iteration</strong>.</p>
</div>
</div>
<p>Sometimes an algorithm designer will know how many times to repeat a certain task (i.e., how many iterations are needed). For this reason, there are many different types of repetition. Some repeat while a condition exists (we formally call this a <strong>while</strong> loop); some repeat until a condition exists (we formally call this a <strong>repeat-until</strong> loop); some repeat at least once, while a condition exists (we formally call this a <strong>do-while</strong> loop); and some repeat a fixed or known number of times (we formally call this a <strong>repeat-n</strong> loop or a <strong>for</strong> loop, depending on the programming language used). Flowcharts make the process of repetition easy because connecting arrows can easily be placed to go back to an earlier task.</p>
<p>For the next task, let’s design an algorithm that finds and displays all the prime numbers that are less than 10. Listing all of the prime numbers that are less than 10 is a fairly easy task. However, what about listing all the prime numbers that are less than 100? What about those that are less than 1,000? Or 10,000? As the number gets larger, it becomes much more complicated. This is why designing an algorithm that a computer could execute would be beneficial. Such an algorithm would calculate all of the required prime numbers faster than we could calculate them on our own.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Did you know">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Did you know
</div>
</div>
<div class="callout-body-container callout-body">
<p>In algorithms where a certain task is repeated, it is often necessary to keep track of how many times it has been completed. This is done by declaring and updating what is referred to as a <strong>variable</strong>. Think of a variable as a container with a name in which we store any piece of data, potentially change it, observe it, and/or compare it with another piece of data as the algorithm is executed.</p>
<p>In the case of repetition, a variable is typically used to represent a number showing how many times a task has been completed. The variable can be called any name we want (the name could be a single letter such as x or n, or even a long word such as <em>theVariableStoringTheValueOfOurCounter</em>). The variable is typically initialized to 0 and is increased by 1 every time a task is completed. When the entire algorithm terminates, the variable will contain the total number of times the task was completed.</p>
</div>
</div>
<p>The design of an algorithm that displays all of the prime numbers that are less than 10 requires defining what it means for a number to be prime. Formally, a number is prime if it is only evenly divisible by one and itself. For example, 5 is prime but 4 is not (since it is also evenly divisible by 2). The only even prime number is 2.</p>
<p>To simplify the process of designing the algorithm, let’s define a variable, n, to be used to specify the current prime number candidate. Let’s also define a <em>magic</em> step (called <em>is n prime</em>) that will be used to determine whether <em>n</em> is prime (i.e., let’s not do this manually but assume that the question can be asked and an answer provided in a single step). A possible algorithm as a flowchart is:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-08.png" class="img-fluid figure-img"></p>
</figure>
</div>
<p>Notice that in the algorithm above, <em>is n prime</em> is repeated for every number (2 through 9 – which is a total of 8 times). If the conditions of the algorithm were changed to find all of the prime numbers below 100, <em>is n prime</em> would be repeated for every number from 2 through 99 (a total of 98 times). This algorithm isn’t the most <em>efficient</em> algorithm, but it gets the job done.</p>
<p>Sometimes the algorithm designer does not know how many times a process is going to be repeated. In such cases, a condition that is needed to be satisfied before the repetition is ended will have to be specified. The statement would then be repeated until that condition is reached. For example, what would an algorithm for stirring sugar into a cup of coffee look like? Would it require stirring five times? 10 times? 100 times? There is no way to tell ahead of time how many times one would have to stir to get the sugar dissolved. However, we know that the stirring should go on while the sugar is not completely dissolved. A possible solution to this is:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-09.png" class="img-fluid figure-img"></p>
</figure>
</div>
</section>
<section id="efficiency-and-runtime" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="efficiency-and-runtime"><span class="header-section-number">6</span> Efficiency and runtime</h2>
<p>It is sometimes useful to measure and predict the time a computer takes to execute an algorithm. This can help us to compare several solutions to a problem and pick the fastest one, for example.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Definition">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Runtime</strong> is the time that a computer takes to execute an algorithm.</p>
</div>
</div>
<p>Most of the algorithms that we have previously considered execute all of their statements once. As a result, they would not take long to be executed by a typical computer (i.e., their runtime would be low). However, algorithms that require repetition have a longer runtime. Consider the <em>find all prime numbers</em> algorithm. If it was adjusted to find all the prime numbers below 100, it would take considerably longer than if it was set to find all the prime numbers below 10. It would take even longer to find all the prime numbers below 1,000. This is because the <em>check if prime</em> process is evaluated for every prime number candidate, and each time it is evaluated the runtime increases.</p>
<p>It is typically desired to design algorithms that have as short of a runtime as possible. Sometimes this calls for designing more intricate or complicated ones; however, only as long as we are sure that the complicated algorithm will have a shorter runtime than the basic algorithm.</p>
<p>Let’s take a look at an interesting problem that will help to show the differences between an algorithm that works and an algorithm that works and is <em>efficient</em>. Consider a square room and an unlimited number of identical square tiles. Can an algorithm be designed to calculate the number of tiles required to cover the entire floor of the room?</p>
<p>There are several ways that this algorithm can be designed.</p>
<ul>
<li><p>One approach is to lay down tiles in the entire room and then count them.</p></li>
<li><p>Another approach may be to lay down tiles in half of the room, count the number of tiles used, and then double that number.</p></li>
<li><p>A third approach may be to lay tiles along one edge of the floor, and multiply the number of tiles laid by itself (i.e., squaring it to find the area of the floor).</p></li>
</ul>
<p>The following figure shows the three methods, side-by-side.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Lesson03-10.png" class="img-fluid figure-img"></p>
</figure>
</div>
<p>Which solution do you think is the best? What does <em>best</em> mean? Does it mean that the algorithm takes less time? Does it mean that it requires fewer tiles? Does it mean that it requires fewer calculations (and is perhaps less prone to arithmetic errors)? Is there a solution that does not require laying down any tiles at all?</p>
<p>Having multiple solutions (or algorithms) to the same problem is a frequent scenario in computer science. We have mentioned before that best is a very subjective measure for an algorithm. However, there is still a need to compare algorithms and determine which algorithm is better. One of the ways of <strong>quantitatively</strong> (i.e., numerically) comparing is by using the algorithm’s runtime. Let’s take a closer look at some algorithms that solve the tile laying problem. For simplicity, we will assume that both the room and tiles are square in shape (i.e., the number of tiles required to cover adjacent edges is equal). Note that the algorithm steps are numbered, with sub-steps placed within a single algorithm.</p>
<p>Algorithm 1 (this one covers the entire floor with tiles):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>1. set number of tiles currently laid to 0</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>2. repeat the following steps until the entire floor is covered</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    2.1. lay a tile on the floor</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    2.2. add one to the number of tiles currently laid</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>3. the number of tiles currently laid is the number of tiles needed</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Algorithm 2 (this one covers half of the floor with tiles):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>1. set number of tiles currently laid to 0</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>2. repeat the following steps until half of the floor is covered</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    2.1. lay a tile on the floor</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    2.2. add one to the number of tiles currently laid</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>3. multiply the number of tiles currently laid by 2</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>4. the result is the number of tiles needed</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Algorithm 3 (this one covers the length of one wall with tiles):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>1. set number of tiles currently laid to 0</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>2. repeat the following steps until one row has been laid</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    2.1. lay a tile on the floor</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    2.2. add one to the number of tiles currently laid</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>3. multiply the number of tiles currently laid by itself</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>4. the result is the number of tiles needed</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We are now going to figure out which algorithm is better between Algorithm 1 and Algorithm 3 using their runtime. Suppose that the room is 12ft x 12ft and each tile is 1ft x 1ft. Also assume that it takes 10 seconds to lay each tile. How long will Algorithm 1 take to be completely executed? Since Algorithm 1 calls for tiles to be laid across the entire room, the 12ft x 12ft room would then require 144 tiles. Since it takes 10 seconds to lay each tile, it would then take 1,440 seconds to cover the entire room. This is 24 minutes:</p>
<p><span class="math display">\[ 1,440 sec \times \frac{1 min}{60 sec} = 24 min\]</span></p>
<div class="callout callout-style-default callout-note callout-titled" title="Did you know">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Did you know
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Dimensional analysis</strong> is a nice way to work through problems with different units (like minutes and seconds), and that require conversion across them. The basic idea is that values can be multiplied by conversion (or dimensional) units that are expressed as fractions. Those units can be canceled out if they appear in both the numerator and denominator. The example above can be rewritten as follows:</p>
<p><span class="math display">\[ \frac{1,440 sec}{1} \times \frac{1 min}{60 sec} = 24 min\]</span></p>
<p>The <em>sec</em> units in the numerator of the first fraction and the denominator of the second fraction cancel each other out, thereby leaving <em>min</em> as the final unit. Here’s another example that converts days to seconds:</p>
<p><span class="math display">\[ \frac{1 day}{1} \times \frac{24 hr}{1 day} \times \frac{60 min}{1 hr}
\times \frac{60 sec}{1 min} = 86,400 sec\]</span></p>
<p>The day, hr, and min units in the numerator and denominator of the fractions cancel each other out. The only unit left is sec which, once the numerators and denominators are multiplied, represent the number of seconds in one day.</p>
</div>
</div>
<p>What about Algorithm 3? This algorithm only calls for laying down tiles along one edge of the room to make one row. This means that only 12 tiles will be laid down using this algorithm, a process that would take 120 sec (2 min). But Algorithm 3 also requires a calculation. Let’s assume that this calculation takes 60 sec.&nbsp;The total runtime for Algorithm 3 is then 120 sec + 60 sec = 180 sec (3 min).</p>
<p>So Algorithm 3 is 21 minutes faster than Algorithm 1 for a 12ft x 12ft room. But what happens if the size of the room is changed? What is the performance of both algorithms if they were used to tile a room that is 20ft x 20ft, under the same timing assumptions as before?</p>
<p>We find that Algorithm 1 takes approximately 1 hr 7 min:</p>
<p><span class="math display">\[ \frac{400 tiles}{1} \times \frac{10 sec}{1 tile} = 4,000 sec \]</span> <span class="math display">\[ \frac{400 sec}{1} \times \frac{1 sec}{60 sec} \times \frac{1 hr}{60
min} = 1.11 hr \]</span> <span class="math display">\[ \frac{0.11 hr}{1} \times \frac{60 min}{1 hr} = 6.6 min \]</span> <span class="math display">\[ \frac{0.6 min}{1} \times \frac{60 sec}{1 min} = 36 sec \]</span></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>